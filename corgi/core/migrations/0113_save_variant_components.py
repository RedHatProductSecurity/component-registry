# Generated by Django 3.2.22 on 2023-12-13 05:46

from django.db import migrations
from django.db.models import F, Func, JSONField, Value

from corgi.core.constants import MODEL_NODE_LEVEL_MAPPING
from corgi.core.models import ProductComponentRelation, ProductNode, ProductVariant
from corgi.tasks.common import slow_save_taxonomy


def save_product_taxonomy_for_inferred_variants(apps, schema_editor) -> None:
    meta_attr_key = "inferred_variants_saved"
    meta_attr_func = Func(
        F("meta_attr"),
        Value([meta_attr_key]),
        Value(True, JSONField()),
        function="jsonb_set",
    )
    inferred_variants = set()
    for pnode in ProductNode.objects.filter(
        level=MODEL_NODE_LEVEL_MAPPING["ProductVariant"],
        node_type=ProductNode.ProductNodeType.INFERRED,
    ):
        if not pnode.obj.meta_attr.get(meta_attr_key):
            inferred_variants.add(pnode.obj.name)
    for inferred_variant in inferred_variants:
        for software_build_details in (
            ProductComponentRelation.objects.filter(
                type__in=ProductComponentRelation.VARIANT_TYPES, product_ref=inferred_variant
            )
            .values("build_id", "build_type")
            .distinct()
        ):
            kwargs = software_build_details
            kwargs["save_components"] = False
            slow_save_taxonomy.apply_async(
                kwargs=kwargs,
                priority=9,
            )
        ProductVariant.objects.filter(name=inferred_variant).update(meta_attr=meta_attr_func)


class Migration(migrations.Migration):
    # rely on slow_save_taxonomy being a task singleton to eliminate duplicate tasks if this
    # migration is run in quick succession (due to init-container timeout)
    atomic = False
    dependencies = [
        ("core", "0112_product_stream_variant_many_to_many"),
    ]

    operations = [migrations.RunPython(save_product_taxonomy_for_inferred_variants)]
